# 分布式

## 一、分布式

### 1. 什么是分布式?

==参考答案==

分布式或者说 SOA 分布式重要的就是**面向服务**，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等，拆分之后的每个服务可以部署在不同的机器上，如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。

### 2.  为什么要分布式?

==参考答案==

从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加便于维护和扩展。

### 3. 什么是CAP原则？

==参考答案==

CAP定理又称CAP原则，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），<font color="red">**最多只能同时三个特性中的两个，三者不可兼得。**</font>

<img src="https://raw.githubusercontent.com/ayifuture0920/java-study/main/pictures/image-20220717121910726.png" alt="image-20220717121910726" style="zoom:50%;" />

- **Consistency (一致性)**：

  用户访问分布式系统中的任意节点，得到的数据必须一致，这就是分布式的一致性。一致性的问题在并发系统中不可避免，从服务端来看，是一个节点的更新如何同步到整个系统，以保证数据最终一致。

- **Availability (可用性)**：

  用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。好的可用性主要是指系统能够很好地为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。

- **Partition Tolerance (分区容错性)**：

  - **Partition（分区）**：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。
  - **Tolerance（容错）**：在集群出现分区时，整个系统也要持续对外提供服务



> **当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。**
>
> 简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。

因此，**分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。** 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。



**为啥不可能选择 CA 架构呢？** 举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。

选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。

另外，需要补充说明的一点是： **如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。**

### 4. BASE 理论

==参考答案==

**BASE** 是 **Basically Available（基本可用）** 、**Soft-state（软状态）** 和 **Eventually Consistent（最终一致性）** 三个短语的缩写。

BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。

- **Basically Available** **（基本可用）**：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。

- **Soft State（软状态）：**软状态指允许系统中的数据存在中间状态（**CAP 理论中的数据不一致**），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点进行数据同步时存在延时。

- **Eventually Consistent（最终一致性）**：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。

  >分布式一致性的 3 种级别：
  >
  >1. **强一致性** ：系统写入了什么，读出来的就是什么。
  >2. **弱一致性** ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。
  >3. **最终一致性** ：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。
  >
  >**业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。**

## 二、zookeeper

分布式集群工作情况下，属于多JVM的工作环境，跨JVM之间已经无通过多线程的锁解决同步问题，那么就需要一种更加高级的锁机制——**分布式锁**，是用来**处理跨机器的进程之间的数据同步问题**

### 1. 分布式锁的实现

- 基于缓存实现分布式锁：**`Redis`、`Memcache`** 

- zookeeper实现分布式锁：**`Curator`**
- 数据库层面实现分布式锁：悲观锁、乐观锁

### 2. `ZooKeeper`分布式锁原理

![image-20220522105804539](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220522105804539.png)

**核心思想：当客户端要获取锁，则创建节点，使用完锁，则删除该节点。**

1.客户端获取锁时，在lock节点下创建临时顺序节点。

2.然后获取lock下面的所有子节点，客户端获取到所有的子节点之后，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁。使用完锁后，将该节点删除。

3.如果发现自己创建的节点并非lock所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，同时对其注册事件监听器，监听删除事件。

4.如果发现比自己小的那个节点被删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是lock子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。



**为什么要创建临时顺序节点？**

临时：防止客户端宕机导致锁无法被释放

顺序：方便查找lock下最小的子节点

### 3. 谈下你对 Zookeeper 的认识？

`ZooKeeper` 是一个分布式的，开源分布式应用程序协调服务。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。

`ZooKeeper` 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。

`Zookeeper`保证了如下分布式一致性特性：

- 顺序一致性
- 原子性
- 单一视图
- 可靠性
- 实时性（最终一致性）

### 4. Zookeeper 都有哪些功能？

- **集群管理**：监控节点存活状态、运行请求等；
- **主节点选举**：主节点挂掉了之后可以从备用的节点开始新一轮选举，主节点选举说的就是这个选举的过程，使用 Zookeeper 可以协助完成这个过程；
- **分布式锁**：`Zookeeper` 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。`Zookeeper` 可以对分布式锁进行控制。
-  **命名服务**：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。

### 5. 谈下你对 ZAB 协议的了解？

`ZAB (Zookeeper Atomic Broadcast)` 协议是`Zookeeper` 专门设计的一种支持崩溃恢复的**原子广播协议**。这个协议保证了分布式事务的最终一致性（主从节点的状态同步）。`ZAB` 协议包括两种基本的模式：**崩溃恢复**和**消息广播**。



**崩溃恢复**：当整个 `Zookeeper` 集群刚刚启动或者`Leader`服务器宕机、重启或者网络故障导致不存在过半的服务器与 `Leader` 服务器保持正常通信时，所有服务器进入崩溃恢复模式，首先选举产生新的 `Leader` 服务器，然后集群中 `Follower` 服务器开始与新的 `Leader` 服务器进行数据同步。当集群中超过半数机器与该 `Leader` 服务器完成数据同步之后，退出恢复模式进入消息广播模式。

**消息广播**：类似一个两阶段提交过程，针对客户端的事务请求， `Leader` 服务器会为其生成对应的事务 `Proposal`，并将其发送给集群中的其余所有机器，再分别收集各自的选票，最后进行事务提交。


### 6. Zookeeper 有几种部署模式？

Zookeeper 有三种部署模式：

- 单机部署：一台集群上运行；

- 集群部署：多台集群运行；

- 伪集群部署：一台集群启动多个 `Zookeeper` 实例运行。


### 7. Zookeeper提供了什么？

**文件系统** 和 **通知机制**

#### 7.1 Zookeeper文件系统

Zookeeper提供一个多层级的节点命名空间（节点称为`ZNode`）。与普通文件系统不同的是，这些节点都可以设置关联的数据，而普通文件系统中只有文件节点可以存放数据而目录节点不行。 `Zookeeper`为了保证高吞吐率和低延迟，在内存中维护了这个树状的目录结构，这种特性使得`Zookeeper`不能用于存放大量的数据，每个节点的存放数据上限为1M。

#### 7.2 Zookeeper 通知机制

Client 端会对某个 `ZNode` 建立一个 **watcher** 事件，当该 `ZNode` 发生变化时，这些 client 会收到 zk 的通知，然后 client 可以根据 `ZNode` 变化来做出业务上的改变等。

### 8.zookeeper  集群中的角色

| 角色 | 描述                                                         |
| :-----------------: | :----------------------------------------------------------- |
|  领导者（Leader）  | 领导者负责进行投票的发起和决议，更新系统状态                 |
| 跟随者（Follower） | Follower用于接收客户请求并向客户端返回结果，在选主过程中进行投票 |
| 观察者（Observer） | Observer可以接收客户端连接，将写请求转发给Leader节点，但Observer不参加选票过程，只同步Leader的状态。Observer的目的是为了扩展系统，提高读取速度。 |

所有的事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器叫：Leader 服务器。其他的服务器被称为 Follower 服务器。Leader 服务器将客户端事务请求转化成一个事务 Proposal（提议），并将改 Proposal 分发给集群中所有的 Follower 服务器。之后 Leader 服务器接收了正确的反馈后，那么 Leader 就会再次向所有的 Follower 服务器分发 Commit 消息，要求将前一个 Proposal 提交。

- **Leader** ：负责整个Zookeeper 集群工作机制中的核心，主要工作有以下两个：

  a. 事务请求的唯一调度和处理者，保证集群事务处理的顺序性

  b. 集群内部各服务器的调度者

- **Follower** ：它是 Leader 的追随者，其主要工作有三个：

  a. 处理客户端的非事务请求，转发事务请求给 Leader 服务器

  b. 参与事务请求 Proposal 的投票

  c. 参与 Leader 选举投票

- **Observer** ：是 zookeeper 自 3.3.0 开始引入的一个角色，它不参与事务请求 Proposal 的投票，也不参与 Leader 选举投票，只提供非事务的服务（查询），通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。

### 9. 四种类型的数据节点 `ZNode`

（1）**PERSISTENT-持久节点**

除非手动删除，否则节点一直存在于 Zookeeper 上

（2）**EPHEMERAL-临时节点**

临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。

（3）**PERSISTENT_SEQUENTIAL-持久化顺序节点**

基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。

（4）**EPHEMERAL_SEQUENTIAL-临时顺序节点**

基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。

### 10. 集群中为什么要有主节点？

在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行 Leader 选举。

### 11. 集群中有 3 台服务器，其中1个节点宕机，这个时候 Zookeeper 还可以使用吗？. 

可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。

集群规则为 2N+1 台，N >0，即最少需要 3 台。

### 12. Zookeeper 宕机如何处理？

Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失；如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。

Zookeeper 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 Zookeeper 节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。所以：

3 个节点的 Cluster 可以挂掉 1 个节点(leader 可以得到 2 票 > 1.5)

2 个节点的 Cluster 就不能挂掉任何1个节点了(leader 可以得到 1 票 <= 1)

### 13. Zookeeper 和 Dubbo 的关系？

#### 13.1 zookeeper的作用：

zookeeper用来注册服务和进行负载均衡，哪一个服务由哪一个机器来提供必需让调用者知道，简单来说就是ip地址和服务名称的对应关系。当然也可以通过硬编码的方式把这种对应关系在调用方业务代码中实现，但是如果提供服务的机器挂掉调用者无法知晓，如果不更改代码会继续请求挂掉的机器提供服务。zookeeper通过心跳机制可以检测挂掉的机器并将挂掉机器的 ip 和服务对应关系从列表中删除。至于支持高并发，简单来说就是横向扩展，在不更改代码的情况通过添加机器来提高运算能力。通过添加新的机器向 zookeeper 注册服务，服务的提供者多了能服务的客户就多了。

#### 13.2 Dubbo：

是管理中间层的工具，在业务层到数据仓库间有非常多服务的接入和服务提供者需要调度，Dubbo提供一个框架解决这个问题。
注意这里的Dubbo只是一个框架，至于你架子上放什么是完全取决于你的，就像一个汽车骨架，你需要配你的轮子引擎。这个框架中要完成调度必须要有一个分布式的注册中心，储存所有服务的元数据，你可以用zk，也可以用别的（如 Redis ），只是大家都用zk。

#### 13.3 zookeeper和Dubbo的关系：

Dubbo 将注册中心进行抽象，它可以外接不同的存储媒介给注册中心提供服务，有 zookeeper ，Memcached，Redis 等。

引入了 zookeeper 作为存储媒介，也就把 zookeeper 的特性引进来。

- 首先是**负载均衡**，单注册中心的承载能力是有限的，在流量达到一定程度的时 候就需要分流，负载均衡就是为了分流而存在的，一个 zookeeper 集群配合相应的 Web 应用就可以很容易达到负载均衡；
- **资源同步**，单单有负载均衡还不够，节点之间的数据和资源需要同步，zookeeper 集群就天然具备有这样的功能；
- **命名服务**，将树状结构用于维护全局的服务地址列表，服务提供者在启动 的时候，向 zookeeper 上的指定节点 /dubbo/${serviceName}/providers 目录下写入自己的 URL 地址，这个操作就完成了服务的发布。 其他特性还有 Mast 选举，分布式锁等。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/31/16e219bc770098df~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

## 三、Dubbo

## RPC

### 1. 何为RPC？

**RPC（Remote Procedure Call）** 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。

**为什么要 RPC ？** 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP 还是 UDP）、序列化方式等等方面。

**RPC 能帮助我们做什么呢？** 简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。

举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。

一言蔽之：**RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。**

### 2. RPC 的原理是什么?

我们可以将整个 RPC的 核心功能看作是下面👇5 个部分实现的：

1. **客户端（Service Consumer）** ：调用远程方法的一端。
2. **客户端 Stub（桩）** ： 这其实就是一代理类。代理类主要做的事情很简单，就是把需要调用的方法、类、方法参数等信息传递到服务端。
3. **网络传输** ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket或者性能以及封装更加优秀的 Netty（推荐）。
4. **服务端 Stub（桩）** ：这个桩就不是代理类了。*我觉得理解为桩实际不太好，大家注意一下就好。*这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去执行对应的方法然后返回结果给客户端 的类。
5. **服务端（Service Provider）** ：提供远程方法的一端。

具体原理图如下，后面我会串起来将整个RPC的过程给大家说一下。

![RPC原理图](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/37345851.jpg)

1. 客户端（client）以本地调用的方式调用远程服务；
2. 客户端 Stub（client stub） 接收到调用请求后负责将方法、参数等进行**序列化**：`RpcRequest`；
3. 客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；
4. 服务端 Stub（桩）收到消息将消息**反序列化**为Java对象: `RpcRequest`；
5. 服务端 Stub（桩）根据`RpcRequest`中的类、方法、方法参数等信息调用本地的方法；
6. 服务端 Stub（桩）得到方法执行结果并对其进行**序列化**：`RpcResponse`，发送至消费方；
7. 客户端 Stub（client stub）接收到消息并将消息**反序列化**为Java对象:`RpcResponse` ，这样也就得到了最终结果。

---

## Dubbo架构

### 1. Dubbo 架构中的核心角色有哪些？

[**Apache Dubbo**](https://github.com/apache/dubbo) |ˈdʌbəʊ| 是一款高性能、轻量级的开源 Java RPC 框架。

![dubbo-relation](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/源码/dubbo/dubbo-relation.jpg)

- **Container：** 服务运行容器，负责加载、运行服务提供者。必须。
- **Provider：** 提供服务的服务提供方，会向注册中心注册自己提供的服务。必须。
- **Consumer：** 调用远程服务的服务消费方，会向注册中心订阅自己所需的服务。必须。
- **Registry：** 服务注册中心。注册中心会返回服务提供者的地址列表给消费者。非必须。
- **Monitor：** 统计服务的调用次数和调用时间的监控中心。服务消费者和提供者会定时发送统计数据到监控中心。 非必须。

### 2. 注册中心

#### 注册中心的作用了解么？

注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在**启动时**与注册中心交互。

#### 注册中心挂了，服务是否可以正常访问？

可以，因为dubbo服务消费者在第一次调用时，会将服务提供方地址缓存到本地，以后在调用则不会访问注册中心。当服务提供者地址发生变化时，注册中心会通知服务消费者。

#### 服务提供者宕机后，注册中心会做什么？

注册中心会立即推送事件通知消费者。

####  监控中心的作用呢？

监控中心负责统计各服务调用次数，调用时间等。

#### 注册中心和监控中心都宕机的话，服务都会挂掉吗？

不会。两者都宕机也不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。

### 3. Dubbo的负载均衡策略

#### 什么是负载均衡？

我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。

#### Dubbo 提供的负载均衡策略有哪些？

在集群负载均衡时，Dubbo 提供了多种均衡策略，默认为 `random` 随机调用。我们还可以自行扩展负载均衡策略（参考Dubbo SPI机制）。

在 Dubbo 中，所有负载均衡实现类均继承自 `AbstractLoadBalance`，该类实现了 `LoadBalance` 接口，并封装了一些公共的逻辑。

`AbstractLoadBalance` 的实现类有下面这些：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220521112233094.png" alt="image-20220521112233094" style="zoom:150%;" />

- **RandomLoadBalance**

根据权重随机选择（对加权随机算法的实现）。这是Dubbo默认采用的一种负载均衡策略。

- **LeastActiveLoadBalance**

`LeastActiveLoadBalance` 直译过来就是**最小活跃数负载均衡**。**Dubbo 认为谁的活跃数越少，谁的处理速度就越快，性能也越好，这样的话，我就优先把请求给活跃数少的服务提供者处理。**如果有多个服务提供者的活跃数相等就再走一遍 `RandomLoadBalance` 。

- **ConsistentHashLoadBalance**

在分库分表、各种集群中就经常使用这个负载均衡策略。

`ConsistentHashLoadBalance` 即**一致性Hash负载均衡策略**。 `ConsistentHashLoadBalance` 中没有权重的概念，具体是哪个服务提供者处理请求是由你的请求的参数决定的，也就是说相同参数的请求总是发到同一个服务提供者。

另外，Dubbo 为了避免数据倾斜问题（节点不够分散，大量请求落到同一节点），还引入了虚拟节点的概念。通过虚拟节点可以让节点更加分散，有效均衡各个节点的请求量。

- **RoundRobinLoadBalance**

**加权轮询负载均衡**。轮询就是把请求依次分配给每个服务提供者。加权轮询就是在轮询的基础上，让更多的请求落到权重更大的服务提供者上。比如假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。如果我们有 10 次请求，那么 7 次会被 S1处理，3次被 S2处理。

### 4. 集群容错

集群容错模式：

- Failover Cluster：失败重试。默认值。当出现失败，重试其它服务器 ，默认重试2次，使用 retries 配置。一般用于读操
- Failfast Cluster ：快速失败，只发起一次调用，失败立即报错。通常用于写操作。
- Failsafe Cluster ：失败安全，出现异常时，直接忽略。返回一个空结果。
- Failback Cluster ：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。
- Forking Cluster ：并行调用多个服务器，只要一个成功即返回。
- Broadcast  Cluster ：广播调用所有提供者，逐个调用，任意一台报错则报错。

### 5. Dubbo 中的 Invoker 概念了解么？

简单来说，`Invoker` 就是 Dubbo 对远程调用的抽象。

![dubbo_rpc_invoke.jpg](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/dubbo_rpc_invoke.jpg)

按照 Dubbo 官方的话来说，`Invoker` 分为

- **服务提供 `Invoker`**
- **服务消费 `Invoker`**

假如我们需要调用一个远程方法，我们需要动态代理来屏蔽远程调用的细节！我们屏蔽掉的这些细节就依赖对应的 `Invoker` 实现， `Invoker` 实现了真正的远程服务调用

